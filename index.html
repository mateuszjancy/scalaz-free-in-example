<!DOCTYPE html>
<html>
<head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        }
        .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
</head>
<body>
<textarea id="source">

<pre>
______              ___  ___                      _
|  ___|             |  \/  |                     | |
| |_ _ __ ___  ___  | .  . | ___  _ __   __ _  __| |___
|  _| '__/ _ \/ _ \ | |\/| |/ _ \| '_ \ / _` |/ _` / __|
| | | | |  __/  __/ | |  | | (_) | | | | (_| | (_| \__ \
\_| |_|  \___|\___| \_|  |_/\___/|_| |_|\__,_|\__,_|___/
                                        by Mateusz Jancy
</pre>

---
##Plan:
* Explain motivation.
* Go with simple example.
* Explain mechanics behind.
* Pizza.
* Show Scalaz.
* Recap with example.
* Done.

---

# Problem
### How to handle common problems in easy to compose way?
* I need to read something, process and store the result.
* I need to compose those basic operations in some services.

### How to avoid complex structures?
* Reader Monad?
* What services should be returned? ReaderT with a wider scope?

---
<pre>
 _______  _______  _______  __   __  __   __   __
|  _    ||       ||       ||  |_|  ||  | |  | |  |
| |_|   ||   _   ||   _   ||       ||  | |  | |  |
|       ||  | |  ||  | |  ||       ||  | |  | |  |
|  _   | |  |_|  ||  |_|  ||       ||__| |__| |__|
| |_|   ||       ||       || ||_|| | __   __   __
|_______||_______||_______||_|   |_||__| |__| |__|

</pre>
---
# Done...
```scala
trait Example {
  val mailService: MailService
  val metaService: MetaService
  val userService: UserService

  def removeAccount(login: String): Unit
  def createAccount(firstName: String, lastName: String): User
  def chaneLastName(login: String, lastName: String) = {
    val user: Option[User] = userService.getUser(login)
    val noUserFound: Either[Throwable, User] =
      Left(new Exception("No User"))

    user.fold(noUserFound) { u =>
      removeAccount(login)
      val user = createAccount(u.firstName, lastName)
      Right(user)
    }
  }
}
```

---

# Task
### So let’s assume that we have a number quiz:
* As a user I want to guess a random number generated by a program.
* As a user I want to know if my guess was correct or not.

### Free monad in short
* Building blocks.
* Free Monad.
* Interpreter.

Program will be described as a sequence of the building blocks.

Program can be passed to an interpreter in order to be executed.

---

# Building blocks
###Let's build a small language which allows us to express our programs.
* It should represent the basic building blocks of our application.
* We will use them to represent sequence of instructions/operations.
* Instructions vs. program execution.
* No side effects.

```scala
sealed trait Lang[Next]
case class RandomNumber[Next](next: Int => Next) extends Lang[Next]
case class Guess[Next](next: Int => Next) extends Lang[Next]
case class Answer[Next](number: Int, answer: Int, next: Next) extends Lang[Next]
```

### Or like in classic repository scenario.
```scala
sealed trait Lang[Next]
case class CreateUser...
case class ReadUser...
case class UpdateUser...
case class DeleteUser...
```

---

# Building blocks

### How to compose them?

```scala
val r: Lang[Lang[Lang[Unit]]] =
    RandomNumber(number => Guess(answer => Answer(number, answer, ())))
```

### Type looks like:
```scala
Option[Option[Option[Unit]]]
```

### Solution?

---

# Building blocks

### Do it in monadic style and end with proper type!!!

```scala
val r: Lang[Unit] = for {
    n <- RandomNumber
    g <- Guess
    _ <- Answer(n, g)
} yield ()
```
### Just like with Option.
```scala
val r: Option[Int] = for {
    n <- Option(...)
    g <- Option(...)
} yield ()
```

**But how?**

---

# Monads
## A bit of theory...

> Monads are a natural extension applicative functors,
> and they provide a solution to the following problem:
> If we have a value with context, m a, how do we apply it to
> a function that takes a normal a and returns a value with a context.
[A fist full of Monads](http://eed3si9n.com/learning-scalaz/Monad.html)

* applicative functors -> map plus applicative laws
* value with context, m a -> **Option(10)** in other words: **Some** not null context with integer value
* fn. that takes a normal a and returns a value with a context -> **Int => Option[Int]** -> **flatMap**

---

# Monads
## Good to know:
* Need constructor.
* Need to follow with monad laws for now (let's skip them).
* Will represents a sequence of context aware operations.
* [Brian Beckman: Don't fear the Monad](https://www.youtube.com/watch?v=ZhuHCtR3xq8)

---

# Free Monad
## A bit of theory...

> A free monad generated by a functor is a special case of
> the more general free (algebraic) structure over some underlying structure.
[Haskell wiki](https://wiki.haskell.org/Free_monad)

#### So our case classes:
```scala
sealed trait Lang[Next]
case class RandomNumber[Next](next: Int => Next) extends Lang[Next]
case class Guess[Next](next: Int => Next) extends Lang[Next]
case class Answer[Next](number: Int, answer: Int, next: Next) extends Lang[Next]
```

#### Plus fancy functor and we are done:
```scala
for {
    n <- randomNumber
    g <- guess
    _ <- answer(n, g)
} yield ()
```

---

# Free Monad: Functor
## A bit of theory...

> And now, we’re going to take a look at the Functor typeclass,
> which is basically for things that can be mapped over.
[Functor](http://eed3si9n.com/learning-scalaz/Functor.html)

```scala
trait Functor[F[_]] {
  def map[A, B](a: F[A])(f: A => B): F[B]
}
```
### So:
```scala
sealed trait Lang[Next] <-- F[_]

case class RandomNumber[Next <-- A](next: Int => Next)
    extends Lang[Next] <-- F[A]
```

---
# Free Monad: Functor

### So
```scala
RandomNumber(next: Int => Next) Goes to RandomNumber(n => f(next(n)))
```

### Our functor should looks like:

```scala
implicit val functor = new Functor[Lang] {
    override def map[A, B](lang: Lang[A])(f: (A) => B): Lang[B] =
      lang match {
        case RandomNumber(next) => RandomNumber(n => f(next(n)))
        case Guess(next) => Guess(n => f(next(n)))
        case Answer(n, q, next) => Answer(n, q, f(next))
      }
  }
```

---

# Free monad
## General requirements
* Needs to provide map and flatMap over our case classes.
* Functor will help to map our **Next** part.
* Our **Next** part is our next Free monad (More or Done)

##Context
* **Option** provides contexts of **None** or **Some**
* **Free** monad provides context of **More** (work to do in order to get result) and **Done** (so actual result)

---

# Free monad
```scala
trait Functor[F[_]] { def map[A, B](a: F[A])(f: A => B): F[B] }

case class Done[F[_] : Functor, A](a: A) extends Free[F, A]
case class More[F[_] : Functor, A](k: F[Free[F, A]]) extends Free[F, A]

class Free[F[_], A](implicit F: Functor[F]) {
  def flatMap[B](f: A => Free[F, B]): Free[F, B] = this match {
    case Done(a) => f(a)
    case More(k) =>
      val value = F.map(k)((x: Free[F, A]) => x.flatMap((a: A) => f(a)))
      More[F, B](value)
  }

  def map[B](f: A => B): Free[F, B] = flatMap { x => Done(f(x)) }
}
```
[Rúnar Óli Bjarnason: Dead-Simple Dependency Injection](https://www.youtube.com/watch?v=ZasXwtTRkio)

```
F[_] : Functor -> requires implicit value of type **Functor[F]** (Context Bound)

F[_] -> it represents our **Lang[Next]**
```
---

# Free monad: case class to monad

### User story
* As a user I want try to guess generated by program random number.
* As a user I want to know if my ques was correct or not.

```scala
def randomNumber: Free[Lang, Int] = More(RandomNumber(x => Done(x)))
def guess: Free[Lang, Int] = More(Guess(x => Done(x)))
def answer(number: Int, answer: Int): Free[Lang, Unit] = More(Answer(number, answer, Done(())))
```

### Always from -->>**MORE** to -->>**DONE**!!!

---

# Free monad: composition
##Let's compose something fancy:
* As a user I want try to guess generated by program random number.
* As a user I want to know if my guess was correct or not.

```scala
def quiz: Free[Lang, Unit] = for {
    n <- randomNumber
    g <- guess
    _ <- answer(n, g)
} yield ()
```

---

```scala
//Functor
trait Functor[F[_]] { def map[A, B](a: F[A])(f: A => B): F[B] }
//Context
case class Done[F[_] : Functor, A](a: A) extends Free[F, A]
case class More[F[_] : Functor, A](k: F[Free[F, A]]) extends Free[F, A]
//Monad
class Free[F[_], A](implicit F: Functor[F]) {
  def flatMap[B](f: A => Free[F, B]): Free[F, B] = this match {
    case Done(a) => f(a)
    case More(k) =>
      val value = F.map(k)((x: Free[F, A]) => x.flatMap((a: A) => f(a)))
      More[F, B](value)
  }
  def map[B](f: A => B): Free[F, B] = flatMap { x => Done(f(x)) }
}
//DSL
sealed trait Lang[Next] // See F[_] in functor...
//Composition
def quiz: Free[Lang, Unit] = for { //More will use
    n <- randomNumber   //More(RandomNumber(n => Done(n)))
    g <- guess          //More(RandomNumber(n => More(Guess(g => Done(g)))))
    _ <- answer(n, g)   //More(RandomNumber(n => More(Guess(g => More(Answer(n, g, Done(())))))))
} yield ()
//Plain version
def quiz: Free[Lang, Unit] =
More[Lang, Int](RandomNumber(x => Done(x))).flatMap { n =>
  //More(RandomNumber(n => More(Guess(g => Done(g)))))
  More[Lang, Int](Guess(x => Done(x))).flatMap { g =>
    //More(RandomNumber(n => More(Guess(g => More(Answer(n, g, Done(())))))))
    More[Lang, Unit](Answer(n, g, Done(()))).map(x => ())
  }
}

```

---

# Interpreter
* Single point with the core logic which can grow fast and become super complex.
* Interpreter is also responsible for an error handling.
* No space for quick solutions!!!


```scala
//More(RandomNumber(n => More(Guess(g => More(Answer(n, g, Done(())))))))

def run[T](program: Free[Lang, T]): T = program match {
    case More(RandomNumber(next)) =>
      run(next(Random.nextInt(10)))
    case More(Guess(next)) =>
      println("Try to guess random number (from 0 to 10):")
      run(next(StdIn.readInt()))
    case More(Answer(n, q, next)) =>
      println(if (n == q) "Correct!!" else s"Wrong!!! Correct answer was: $n")
      run(next)
    case Done(done) => done
  }
```

---

# Free Monads: Recap
* DSL as the building blocks.
* With functor which allows us to lift our DSL into monad (map, flatMap).
* Composition which describes our program (sequence of our building blocks).
* Interpreters which pattern match over our DSL and make things happen.
* SimpleMain.scala

---

# Scalaz.Free
### Example in
* SimplezMain.scala

### Changes:
* Free already implemented
* Free.liftF instead More(...Done(...))

---

# And one more thing

### Error handling:
```scala
 def run[T](program: Free[Lang, T]): Either[Throwable, T] = program.resume.fold({
    case RandomNumber(next) =>
      try {
        run(next(Random.nextInt(10)))
      } catch {
        case NonFatal(ex) => run(Free.liftF(Fail(ex)))
      }
    case Guess(next) =>
      println("Try to guess random number (from 0 to 10):")
      run(next(StdIn.readInt()))
    case Answer(n, q, next) =>
      println(if (n == q) "Correct!!" else s"Wrong!!! Correct answer was: $n")
      run(next)
    case Fail(ex) => Left(ex)
  }, (a: T) => Right(a))
```

---

# Pros and cons

### In my opinion:
* Good: nice building blocks
* Good: pure functions
* Good: easy to test
* Bad: hard to maintain
* Bad: not easy for quick fixes
* Bad: complex at the beginning

### In your opinion:
* ...

---

# Go code
### Let's assume that we have already developed services:
* MailService: JavaMail with complex/rich API.
* UserService: LDAP, used across the company, contains all business models.
* MetaService: Our internal metadata operations around user model.

### We need to provide complex combinations of all those three services. For start we will go with Registration user story:
* As a user I want to register an account.
* Aa a user I want to update my last name.
* Each account change needs mail confirmation.

---

# So no more old fashion DI?
```scala
trait Example {
  val mailService: MailService
  val metaService: MetaService
  val userService: UserService

  def removeAccount(login: String): Unit
  def createAccount(firstName: String, lastName: String): User
  def chaneLastName(login: String, lastName: String) = {
    val user: Option[User] = userService.getUser(login)
    val noUserFound: Either[Throwable, User] =
      Left(new Exception("No User"))

    user.fold(noUserFound) { u =>
      removeAccount(login)
      val user = createAccount(u.firstName, lastName)
      Right(user)
    }
  }
}
```

---

# Q&A

---

# Thanks

    </textarea>
<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
</script>
<script>
      var slideshow = remark.create();

</script>
</body>
</html>
