# Problem
### How to handle common problems in easy to compose way?
* I need to read something, process and store the result.
* I need to compose those basic operations in some Services.

### How to avoid complex structures?
* Reader Monad?
* What services should return? ReaderT with wider scope?

---

# Task
### So lets assume that we have a number quiz:
* As a user I want to guess generated by a program random number.
* As a user I want to know if my ques was correct or not.

### Free monad in short
* Building blocks.
* Free Monad.
* Interpreter.

Program will be described by a sequence of building blocks.

Such programs can be passed to an interpreter in order to be executed.

---

# Building blocks
###Let's build small language which allows us to express our programs.
* It should represent basic building blocks of our application.
* We will use them to represent sequence of instructions/operations.
* Instructions vs program execution.
* No side effects.

```scala
sealed trait Lang[Next]
case class RandomNumber[Next](next: Int => Next) extends Lang[Next]
case class Guess[Next](next: Int => Next) extends Lang[Next]
case class Answer[Next](number: Int, answer: Int, next: Next) extends Lang[Next]
```

---

# Building blocks

### How to compose them?

```scala
val r: Lang[Lang[Lang[Unit]]] =
    RandomNumber(number => Guess(answer => Answer(number, answer, ())))
```

### Type looks like:
```scala
Option[Option[Option[Unit]]]
```

### Solution?

---

# Building blocks

### Do it in monadic style and end with proper type!!!

```scala
val r: Lang[Unit] = for {
    n <- RandomNumber
    g <- Guess
    _ <- Answer(n, g)
} yield ()
```

**But how?**

---

# Monads
## Bit theory...

> Monads are a natural extension applicative functors,
> and they provide a solution to the following problem:
> If we have a value with context, m a, how do we apply it to
> a function that takes a normal a and returns a value with a context.
[A fist full of Monads](http://eed3si9n.com/learning-scalaz/Monad.html)

"applicative functors" -> so map function -> so some applicative laws

"value with context, m a" -> **Some(10)** -> in other words: **not null** context with integer value

"fn. that takes a normal a and returns a value with a context" -> **Int => Option[Int]** -> **flatMap**

---

# Monads
## Good to know:
* Bind -> constructor
* Let's skip monad laws for now.
* Monads will represent sequence of context aware operations.
* Hype HINT: read about property based testing*
* [Brian Beckman: Don't fear the Monad](https://www.youtube.com/watch?v=ZhuHCtR3xq8)

---

# Free Monad
## Bit theory...

> A free monad generated by a functor is a special case of
> the more general free (algebraic) structure over some underlying structure.
[Haskell wiki](https://wiki.haskell.org/Free_monad)

#### So our case classes:
```scala
sealed trait Lang[Next]
case class RandomNumber[Next](next: Int => Next) extends Lang[Next]
case class Guess[Next](next: Int => Next) extends Lang[Next]
case class Answer[Next](number: Int, answer: Int, next: Next) extends Lang[Next]
```

#### Plus fancy functor and we are done:
```scala
for {
    n <- randomNumber
    g <- guess
    _ <- answer(n, g)
} yield ()
```

---

# Free Monad: Functor
## Bit theory...

> And now, we’re going to take a look at the Functor typeclass,
> which is basically for things that can be mapped over.
[Functor](http://eed3si9n.com/learning-scalaz/Functor.html)

```scala
trait Functor[F[_]] {
  def map[A, B](a: F[A])(f: A => B): F[B]
}
```

---
# Free Monad: Functor

### Our functor should looks like:

```scala
implicit val functor = new Functor[Lang] {
    override def map[A, B](lang: Lang[A])(f: (A) => B): Lang[B] =
      lang match {
        case RandomNumber(next) => RandomNumber(n => f(next(n)))
        case Guess(next) => Guess(n => f(next(n)))
        case Answer(n, q, next) => Answer(n, q, f(next))
      }
  }
```

### So
```scala
RandomNumber(next: Int => Next) Goes to RandomNumber(n: Int => f(next(n))
```

---

# Free monad
```scala
trait Functor[F[_]] { def map[A, B](a: F[A])(f: A => B): F[B] }

case class Done[F[_] : Functor, A](a: A) extends Free[F, A]
case class More[F[_] : Functor, A](k: F[Free[F, A]]) extends Free[F, A]

class Free[F[_], A](implicit F: Functor[F]) {
  def flatMap[B](f: A => Free[F, B]): Free[F, B] = this match {
    case Done(a) => f(a)
    case More(k) =>
      val value = F.map(k)((x: Free[F, A]) => x.flatMap((a: A) => f(a)))
      More[F, B](value)
  }

  def map[B](f: A => B): Free[F, B] = flatMap { x => Done(f(x)) }
}
```
[Rúnar Óli Bjarnason: Dead-Simple Dependency Injection](https://www.youtube.com/watch?v=ZasXwtTRkio)

```
F[_] : Functor -> requires implicit value of type **Functor[F]** (Context Bound)

F[_] -> it represents our **Lang[Next]**
```
---

# Free monad: case class to monad

### User story
* As a user I want try to guess generated by program random number.
* As a user I want to know if my ques was correct or not.

```scala
def randomNumber: Free[Lang, Int] = More(RandomNumber(x => Done(x)))
def guess: Free[Lang, Int] = More(Guess(x => Done(x)))
def answer(number: Int, answer: Int): Free[Lang, Unit] = More(Answer(number, answer, Done(())))
```

### Always from -->>**MORE** to -->>**DONE**!!!

---

# Free monad: coposition
##Let's compose something fancy:
* As a user I want try to guess generated by program random number.
* As a user I want to know if my ques was correct or not.

```scala
def quiz: Free[Lang, Unit] = for {
    n <- randomNumber
    g <- guess
    _ <- answer(n, g)
} yield ()
```

---

# Free monad
```scala
//Functor
trait Functor[F[_]] { def map[A, B](a: F[A])(f: A => B): F[B] }
//Monad
case class Done[F[_] : Functor, A](a: A) extends Free[F, A]
case class More[F[_] : Functor, A](k: F[Free[F, A]]) extends Free[F, A]
class Free[F[_], A](implicit F: Functor[F]) {
  def flatMap[B](f: A => Free[F, B]): Free[F, B] = this match {
    case Done(a) => f(a)
    case More(k) =>
      val value = F.map(k)((x: Free[F, A]) => x.flatMap((a: A) => f(a)))
      More[F, B](value)
  }
  def map[B](f: A => B): Free[F, B] = flatMap { x => Done(f(x)) }
}
//ADT
sealed trait Lang[Next] // See F[_] in functor
...
//Composition
def quiz: Free[Lang, Unit] = for { //More will use
    n <- randomNumber   //More(RandomNumber(n => Done(n)))
    g <- guess          //More(RandomNumber(n => More(Guess(g => Done(g)))))
    _ <- answer(n, g)   //More(RandomNumber(n => More(Guess(g => More(Answer(n, g, Done(())))))))
} yield ()

```

---

# Interpreter
* Single point with core logic which can grow fast and become super complex.
* I is responsible also for error handling.
* No space for quick solutions!!!


```scala
//More(RandomNumber(n => More(Guess(g => More(Answer(n, g, Done(())))))))

def run[T](program: Free[Lang, T]): T = program match {
    case More(RandomNumber(next)) =>
      run(next(Random.nextInt(10)))
    case More(Guess(next)) =>
      println("Try to guess random number (from 0 to 10):")
      run(next(StdIn.readInt()))
    case More(Answer(n, q, next)) =>
      println(if (n == q) "Correct!!" else s"Wrong!!! Correct answer was: $n")
      run(next)
    case Done(done) => done
  }
```

---

# Free Monads: Recap
* ADT as a building blocks.
* With functor which allows us to lift our ADT into monad (map, flatMap).
* Composition which describes our program (sequence of our building blocks).
* Interpreters which pattern match over our ADT and makes things happen.
* SimpleMain.scala

---

# Scalaz.Free
* SimplezMain.scala

---

# Pros and cons
???

---

# Go code
### Lets assume that we have already developed services:
* MailService: JavaMail with complex/rich API.
* UserService: LDAP, used across the company, contains all business models.
* MetaService: Our internal metadata operations around user model.

### We need to provide complex combinations of all those three services. For start we will go with Registration user story:
* As a user I want to register an account.
* Aa a user I want to update my last name.

### AC
* Each account change needs mail confirmation.

---

# So no more old fashion DI?
```scala
trait Example {
  val mailService: MailService
  val metaService: MetaService
  val userService: UserService

  def removeAccount(login: String): Unit
  def createAccount(firstName: String, lastName: String): User
  def chaneLastName(login: String, lastName: String) = {
    val user: Option[User] = userService.getUser(login)
    val noUserFound: Either[Throwable, User] =
      Left(new Exception("No User"))

    user.fold(noUserFound) { u =>
      removeAccount(login)
      val user = createAccount(u.firstName, lastName)
      Right(user)
    }
  }
}
```

---

# Q&A

---

# Thanks
